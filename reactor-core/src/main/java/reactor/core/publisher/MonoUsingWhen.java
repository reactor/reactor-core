/*
 * Copyright (c) 2011-2018 Pivotal Software Inc, All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package reactor.core.publisher;

import java.util.Objects;
import java.util.concurrent.Callable;
import java.util.function.Function;

import org.reactivestreams.Publisher;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;
import reactor.core.CoreSubscriber;
import reactor.core.Fuseable;
import reactor.util.annotation.Nullable;

/**
 * Uses a resource, generated by a {@link Publisher} for each individual {@link Subscriber},
 * while streaming the values from a {@link Publisher} derived from the same resource.
 * Whenever the resulting sequence terminates, the relevant {@link Function} generates
 * a "cleanup" {@link Publisher} that is invoked but doesn't change the content of the
 * main sequence. Instead it just defers the termination (unless it errors, in which case
 * the error suppresses the original termination signal).
 *
 * @param <T> the value type streamed
 * @param <S> the resource type
 */
final class MonoUsingWhen<T, S> extends Mono<T> implements Fuseable, SourceProducer<T> {

	final Publisher<S>                                     resourceSupplier;
	final Function<? super S, ? extends Mono<? extends T>> resourceClosure;
	final Function<? super S, ? extends Publisher<?>>      asyncComplete;
	final Function<? super S, ? extends Publisher<?>>      asyncError;
	@Nullable
	final Function<? super S, ? extends Publisher<?>>      asyncCancel;

	MonoUsingWhen(Publisher<S> resourceSupplier,
			Function<? super S, ? extends Mono<? extends T>> resourceClosure,
			Function<? super S, ? extends Publisher<?>> asyncComplete,
			Function<? super S, ? extends Publisher<?>> asyncError,
			@Nullable Function<? super S, ? extends Publisher<?>> asyncCancel) {
		this.resourceSupplier = Objects.requireNonNull(resourceSupplier, "resourceSupplier");
		this.resourceClosure = Objects.requireNonNull(resourceClosure, "resourceClosure");
		this.asyncComplete = Objects.requireNonNull(asyncComplete, "asyncComplete");
		this.asyncError = Objects.requireNonNull(asyncError, "asyncError");
		this.asyncCancel = asyncCancel;
	}

	@Override
	@SuppressWarnings("unchecked")
	public void subscribe(CoreSubscriber<? super T> actual) {
		if (resourceSupplier instanceof Callable) {
			try {
				Callable<S> resourceCallable = (Callable<S>) resourceSupplier;
				S resource = resourceCallable.call();

				if (resource == null) {
					Operators.complete(actual);
				}
				else {
					subscribeToResource(resource, actual, resourceClosure,
							asyncComplete, asyncError, asyncCancel);
				}
			}
			catch (Throwable e) {
				Operators.error(actual, e);
			}
			return;
		}

		resourceSupplier.subscribe(new ResourceSubscriber(actual, resourceClosure,
				asyncComplete, asyncError, asyncCancel,
				resourceSupplier instanceof Mono));
	}

	@Override
	public Object scanUnsafe(Attr key) {
		return null; //no particular key to be represented, still useful in hooks
	}

	private static <S, T> void subscribeToResource(S resource,
			CoreSubscriber<? super T> actual,
			Function<? super S, ? extends Mono<? extends T>> resourceClosure,
			Function<? super S, ? extends Publisher<?>> asyncComplete,
			Function<? super S, ? extends Publisher<?>> asyncError,
			@Nullable Function<? super S, ? extends Publisher<?>> asyncCancel) {

		Mono<? extends T> p;

		try {
			p = Objects.requireNonNull(resourceClosure.apply(resource),
					"The resourceClosure function returned a null value");
		}
		catch (Throwable e) {
			//TODO should a closure#apply error translate to a asyncError? (for now it will)
			p = Mono.error(e);
		}

		if (p instanceof Fuseable) {
			p.subscribe(new FluxUsingWhen.UsingWhenFuseableSubscriber<>(actual,
					resource, asyncComplete, asyncError, asyncCancel));
		}
		else if (actual instanceof ConditionalSubscriber) {
			p.subscribe(new FluxUsingWhen.UsingWhenConditionalSubscriber<>((ConditionalSubscriber<? super T>) actual,
					resource, asyncComplete, asyncError, asyncCancel));
		}
		else {
			p.subscribe(new FluxUsingWhen.UsingWhenSubscriber<>(actual, resource, asyncComplete, asyncError, asyncCancel));
		}
	}

	//needed to correctly call subscribeToResource with Mono.from conversions
	static class ResourceSubscriber<S, T> implements InnerConsumer<S> {

		final CoreSubscriber<? super T> actual;

		final Function<? super S, ? extends Mono<? extends T>>      resourceClosure;
		final Function<? super S, ? extends Publisher<?>>           asyncComplete;
		final Function<? super S, ? extends Publisher<?>>           asyncError;
		@Nullable
		final Function<? super S, ? extends Publisher<?>>           asyncCancel;
		final boolean                                               isMonoSource;

		Subscription s;
		boolean      resourceProvided;

		ResourceSubscriber(CoreSubscriber<? super T> actual,
				Function<? super S, ? extends Mono<? extends T>> resourceClosure,
				Function<? super S, ? extends Publisher<?>> asyncComplete,
				Function<? super S, ? extends Publisher<?>> asyncError,
				@Nullable Function<? super S, ? extends Publisher<?>> asyncCancel,
				boolean isMonoSource) {
			this.actual = Objects.requireNonNull(actual, "actual");
			this.resourceClosure = Objects.requireNonNull(resourceClosure, "resourceClosure");
			this.asyncComplete = Objects.requireNonNull(asyncComplete, "asyncComplete");
			this.asyncError = Objects.requireNonNull(asyncError, "asyncError");
			this.asyncCancel = asyncCancel;
			this.isMonoSource = isMonoSource;
		}

		@Override
		public void onNext(S resource) {
			if (resourceProvided) {
				Operators.onNextDropped(resource, actual.currentContext());
				return;
			}
			resourceProvided = true;

			subscribeToResource(resource, actual, resourceClosure,
					asyncComplete, asyncError, asyncCancel);

			if (!isMonoSource) {
				s.cancel();
			}
		}

		@Override
		public void onError(Throwable throwable) {
			if (resourceProvided) {
				Operators.onErrorDropped(throwable, actual.currentContext());
				return;
			}
			//if no resource provided, actual.onSubscribe has not been called
			//let's call it and immediately terminate it with the error
			Operators.error(actual, throwable);
		}

		@Override
		public void onComplete() {
			if (resourceProvided) {
				return;
			}
			//if no resource provided, actual.onSubscribe has not been called
			//let's call it and immediately complete it
			Operators.complete(actual);
		}

		@Override
		public void onSubscribe(Subscription s) {
			if (Operators.validate(this.s, s)) {
				this.s = s;
				s.request(Long.MAX_VALUE);
			}
		}

		@Override
		public Object scanUnsafe(Attr key) {
			if (key == Attr.PARENT) return s;
			if (key == Attr.ACTUAL) return actual;
			if (key == Attr.PREFETCH) return Integer.MAX_VALUE;
			if (key == Attr.TERMINATED) return resourceProvided;

			return null;
		}
	}

}
