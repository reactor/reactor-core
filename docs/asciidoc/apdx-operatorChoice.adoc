[[which-operator]]
= Which operator do I need?

TIP: In this section, if an operator is specific to https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux] or https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono], it is prefixed and linked accordingly, like this: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#fromArray-T:A-[Flux#fromArray]. Common operators have no prefix, and links to both implementations are provided, for example: `just` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#just-T-[Mono]). When a specific use case is covered by a combination of operators, it is presented as a method call, with a leading dot and parameters in parentheses, as follows: `.methodCall(parameter)`.

//TODO flux:  publishOn/subscribeOn/cancelOn
//transformDeferred/transform, repeatWhen, sort, startWith
//TODO Mono.sequenceEqual

I want to deal with:

* <<which.create>>

* <<which.values>>

* <<which.filtering>>

* <<which.peeking>>

* <<which.errors>>

* <<which.time>>

* <<which.window>>

* <<which.blocking>>

* <<which.multicasting>>

[[which.create]]
== Creating a New Sequence...

* that emits a `T`, and I already have: `just` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#just-T-[Mono])
** ...from an https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html[Optional<T>]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#justOrEmpty-java.util.Optional-[Mono#justOrEmpty(Optional<T>)]
** ...from a potentially `null` T: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#justOrEmpty-T-[Mono#justOrEmpty(T)]
* that emits a `T` returned by a method: `just` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#just-T-[Mono]) as well
** ...but lazily captured: use https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromSupplier-java.util.function.Supplier-[Mono#fromSupplier] or wrap `just` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#just-T-[Mono]) inside `defer` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#defer-java.util.function.Supplier-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#defer-java.util.function.Supplier-[Mono])
* that emits several `T` I can explicitly enumerate: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-[Flux#just(T...)]
* that iterates over:
** an array: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#fromArray-T:A-[Flux#fromArray]
** a collection or iterable: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#fromIterable-java.lang.Iterable-[Flux#fromIterable]
** a range of integers: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#range-int-int-[Flux#range]
** a https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html[Stream] supplied for each Subscription: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#fromStream-java.util.function.Supplier-[Flux#fromStream(Supplier<Stream>)]
* that emits from various single-valued sources such as:
** a https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html[Supplier<T>]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromSupplier-java.util.function.Supplier-[Mono#fromSupplier]
** a task: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromCallable-java.util.concurrent.Callable-[Mono#fromCallable], https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromRunnable-java.lang.Runnable-[Mono#fromRunnable]
** a https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html[CompletableFuture<T>]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromFuture-java.util.concurrent.CompletableFuture-[Mono#fromFuture]
* that completes: `empty` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#empty--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#empty--[Mono])
* that errors immediately: `error` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.lang.Throwable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.lang.Throwable-[Mono])
** ...but lazily build the https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html[Throwable]: `error(Supplier<Throwable>)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.util.function.Supplier-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.util.function.Supplier-[Mono])
* that never does anything: `never` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#never--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#never--[Mono])
* that is decided at subscription: `defer` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#defer-java.util.function.Supplier-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#defer-java.util.function.Supplier-[Mono])
* that depends on a disposable resource: `using` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-[Mono])
* that generates events programmatically (can use state):
** synchronously and one-by-one: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#generate-java.util.concurrent.Callable-java.util.function.BiFunction-[Flux#generate]
** asynchronously (can also be sync), multiple emissions possible in one pass: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#create-java.util.function.Consumer-[Flux#create]
(https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#create-java.util.function.Consumer-[Mono#create] as well, without the multiple emission aspect)

[[which.values]]
== Transforming an Existing Sequence

* I want to transform existing data:
** on a 1-to-1 basis (eg. strings to their length): `map` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#map-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#map-java.util.function.Function-[Mono])
*** ...by just casting it: `cast` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cast-java.lang.Class-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#cast-java.lang.Class-[Mono])
*** ...in order to materialize each source value's index: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#index--[Flux#index]
** on a 1-to-n basis (eg. strings to their characters): `flatMap` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#flatMap-java.util.function.Function-[Mono]) + use a factory method
** on a 1-to-n basis with programmatic behavior for each source element and/or state: `handle` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#handle-java.util.function.BiConsumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#handle-java.util.function.BiConsumer-[Mono])
** running an asynchronous task for each source item (eg. urls to http request): `flatMap` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#flatMap-java.util.function.Function-[Mono]) + an async https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html?is-external=true[Publisher]-returning method
*** ...ignoring some data: conditionally return a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#empty--[Mono.empty()] in the flatMap lambda
*** ...retaining the original sequence order: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMapSequential-java.util.function.Function-[Flux#flatMapSequential] (this triggers the async processes immediately but reorders the results)
*** ...where the async task can return multiple values, from a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono] source: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#flatMapMany-java.util.function.Function-[Mono#flatMapMany]

* I want to add pre-set elements to an existing sequence:
** at the start: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#startWith-T%2E%2E%2E-[Flux#startWith(T...)]
** at the end: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concatWithValues-T%2E%2E%2E-[Flux#concatWithValues(T...)]

* I want to aggregate a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux]: (the `Flux#` prefix is assumed below)
** into a List: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectList--[collectList], https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectSortedList--[collectSortedList]
** into a Map: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectMap-java.util.function.Function-[collectMap], https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectMultimap-java.util.function.Function-[collectMultiMap]
** into an arbitrary container: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collect-java.util.stream.Collector-[collect]
** into the size of the sequence: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#count--[count]
** by applying a function between each element (eg. running sum): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#reduce-A-java.util.function.BiFunction-[reduce]
*** ...but emitting each intermediary value: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#scan-A-java.util.function.BiFunction-[scan]
** into a boolean value from a predicate:
*** applied to all values (AND): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#all-java.util.function.Predicate-[all]
*** applied to at least one value (OR): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#any-java.util.function.Predicate-[any]
*** testing the presence of any value: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#hasElements--[hasElements] _(there is a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono] equivalent in https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#hasElement--[hasElement])_
*** testing the presence of a specific value: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#hasElement-T-[hasElement(T)]


* I want to combine publishers...
** in sequential order: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concat-org.reactivestreams.Publisher%2E%2E%2E-[Flux#concat] or `.concatWith(other)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concatWith-org.reactivestreams.Publisher-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#concatWith-org.reactivestreams.Publisher-[Mono])
*** ...but delaying any error until remaining publishers have been emitted: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concatDelayError-org.reactivestreams.Publisher-[Flux#concatDelayError]
*** ...but eagerly subscribing to subsequent publishers: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#mergeSequential-int-org.reactivestreams.Publisher%2E%2E%2E-[Flux#mergeSequential]
** in emission order (combined items emitted as they come): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#merge-int-org.reactivestreams.Publisher%2E%2E%2E-[Flux#merge] / `.mergeWith(other)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#mergeWith-org.reactivestreams.Publisher-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#mergeWith-org.reactivestreams.Publisher-[Mono])
*** ...with different types (transforming merge): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#zip-java.util.function.Function-org.reactivestreams.Publisher%2E%2E%2E-[Flux#zip] / https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#zipWith-org.reactivestreams.Publisher-[Flux#zipWith]
** by pairing values:
*** from 2 Monos into a https://projectreactor.io/docs/core/release/api/reactor/util/function/Tuple2.html[Tuple2]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#zipWith-reactor.core.publisher.Mono-[Mono#zipWith]
*** from n Monos when they all completed: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#zip-java.util.function.Function-reactor.core.publisher.Mono%2E%2E%2E-[Mono#zip]
** by coordinating their termination:
*** from 1 Mono and any source into a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono<Void>]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#and-org.reactivestreams.Publisher-[Mono#and]
*** from n sources when they all completed: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#when-java.lang.Iterable-[Mono#when]
*** into an arbitrary container type:
**** each time all sides have emitted: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#zip-java.util.function.Function-org.reactivestreams.Publisher%2E%2E%2E-[Flux#zip] (up to the smallest cardinality)
**** each time a new value arrives at either side: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#combineLatest-java.util.function.Function-int-org.reactivestreams.Publisher%2E%2E%2E-[Flux#combineLatest]
** selecting the first publisher which...
*** produces a _value_ (`onNext`): `firstWithValue` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#firstWithValue-java.lang.Iterable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#firstWithValue-java.lang.Iterable-[Mono])
*** produces _any signal_: `firstWithSignal` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#firstWithSignal-java.lang.Iterable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#firstWithSignal-java.lang.Iterable-[Mono])
** triggered by the elements in a source sequence: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#switchMap-java.util.function.Function-[switchMap] (each source element is mapped to a Publisher)
** triggered by the start of the next publisher in a sequence of publishers: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#switchOnNext-org.reactivestreams.Publisher-[switchOnNext]

* I want to repeat an existing sequence: `repeat` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#repeat--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#repeat--[Mono])
** ...but at time intervals: `Flux.interval(duration).flatMap(tick -> myExistingPublisher)`

* I have an empty sequence but...
** I want a value instead: `defaultIfEmpty` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#defaultIfEmpty-T-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#defaultIfEmpty-T-[Mono])
** I want another sequence instead: `switchIfEmpty` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#switchIfEmpty-org.reactivestreams.Publisher-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#switchIfEmpty-reactor.core.publisher.Mono-[Mono])

* I have a sequence but I am not interested in values: `ignoreElements` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#ignoreElements--[Flux.ignoreElements()]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#ignoreElement--[Mono.ignoreElement()])
** ...and I want the completion represented as a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono<Void>]: `then` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#then--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#then--[Mono])
** ...and I want to wait for another task to complete at the end: `thenEmpty` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#thenEmpty-org.reactivestreams.Publisher-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#thenEmpty-org.reactivestreams.Publisher-[Mono])
** ...and I want to switch to another https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono] at the end: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#then-reactor.core.publisher.Mono-[Mono#then(mono)]
** ...and I want to emit a single value at the end: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#thenReturn-V-[Mono#thenReturn(T)]
** ...and I want to switch to a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux] at the end: `thenMany` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#thenMany-org.reactivestreams.Publisher-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#thenMany-org.reactivestreams.Publisher-[Mono])

* I have a Mono for which I want to defer completion...
** ...until another publisher, which is derived from this value, has completed: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delayUntil-java.util.function.Function-[Mono#delayUntil(Function)]

* I want to expand elements recursively into a graph of sequences and emit the combination...
** ...expanding the graph breadth first: `expand(Function)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#expand-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#expand-java.util.function.Function-[Mono])
** ...expanding the graph depth first: `expandDeep(Function)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#expandDeep-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#expandDeep-java.util.function.Function-[Mono])

[[which.peeking]]
== Peeking into a Sequence

* Without modifying the final sequence, I want to:
** get notified of / execute additional behavior (sometimes referred to as "side-effects") on:
*** emissions: `doOnNext` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnNext-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnNext-java.util.function.Consumer-[Mono])
*** completion: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnComplete-java.lang.Runnable-[Flux#doOnComplete], https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnSuccess-java.util.function.Consumer-[Mono#doOnSuccess] (includes the result, if any)
*** error termination: `doOnError` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnError-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnError-java.util.function.Consumer-[Mono])
*** cancellation: `doOnCancel` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnCancel-java.lang.Runnable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnCancel-java.lang.Runnable-[Mono])
*** "start" of the sequence: `doFirst` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doFirst-java.lang.Runnable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doFirst-java.lang.Runnable-[Mono])
**** this is tied to https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html?is-external=true#subscribe(org.reactivestreams.Subscriber)[Publisher#subscribe(Subscriber)]
*** post-subscription : `doOnSubscribe` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnSubscribe-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnSubscribe-java.util.function.Consumer-[Mono])
**** `Subscription` acknowledgment after `subscribe`
**** this is tied to https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Subscriber.html?is-external=true#onSubscribe(org.reactivestreams.Subscription)[Subscriber#onSubscribe(Subscription)]
*** request: `doOnRequest` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnRequest-java.util.function.LongConsumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnRequest-java.util.function.LongConsumer-[Mono])
*** completion or error: `doOnTerminate` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnTerminate-java.lang.Runnable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnTerminate-java.lang.Runnable-[Mono])
**** but *after* it has been propagated downstream: `doAfterTerminate` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doAfterTerminate-java.lang.Runnable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doAfterTerminate-java.lang.Runnable-[Mono])
*** any type of signal, represented as a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Signal.html[Signal]: `doOnEach` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnEach-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnEach-java.util.function.Consumer-[Mono])
*** any terminating condition (complete, error, cancel): `doFinally` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doFinally-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doFinally-java.util.function.Consumer-[Mono])
** log what happens internally: `log` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#log--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#log--[Mono])

* I want to know of all events:
** each represented as https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Signal.html[Signal] object:
*** in a callback outside the sequence: `doOnEach` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnEach-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnEach-java.util.function.Consumer-[Mono])
*** instead of the original onNext emissions: `materialize` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#materialize--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#materialize--[Mono])
**** ...and get back to the onNexts: `dematerialize` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#dematerialize--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#dematerialize--[Mono])
** as a line in a log: `log` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#log--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#log--[Mono])

[[which.filtering]]
== Filtering a Sequence

* I want to filter a sequence:
** based on an arbitrary criteria: `filter` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#filter-java.util.function.Predicate-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#filter-java.util.function.Predicate-[Mono])
*** ...that is asynchronously computed: `filterWhen` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#filterWhen-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#filterWhen-java.util.function.Function-[Mono])
** restricting on the type of the emitted objects: `ofType` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#ofType-java.lang.Class-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#ofType-java.lang.Class-[Mono])
** by ignoring the values altogether: `ignoreElements` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#ignoreElements--[Flux.ignoreElements()]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#ignoreElement--[Mono.ignoreElement()])
** by ignoring duplicates:
*** in the whole sequence (logical set): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#distinct--[Flux#distinct]
*** between subsequently emitted items (deduplication): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#distinctUntilChanged--[Flux#distinctUntilChanged]

* I want to keep only a subset of the sequence:
** by taking N elements:
*** at the beginning of the sequence: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#take-long-[Flux#take(long)]
**** ...requesting an unbounded amount from upstream: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#take-long-boolean-[Flux#take(long, false)]
**** ...based on a duration: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#take-java.time.Duration-[Flux#take(Duration)]
**** ...only the first element, as a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#next--[Flux#next()]
*** at the end of the sequence: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeLast-int-[Flux#takeLast]
*** until a criteria is met (inclusive): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeUntil-java.util.function.Predicate-[Flux#takeUntil] (predicate-based), https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeUntilOther-org.reactivestreams.Publisher-[Flux#takeUntilOther] (companion publisher-based)
*** while a criteria is met (exclusive): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeWhile-java.util.function.Predicate-[Flux#takeWhile]
** by taking at most 1 element:
*** at a specific position: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#elementAt-int-[Flux#elementAt]
*** at the end: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeLast-int-[.takeLast(1)]
**** ...and emit an error if empty: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#last--[Flux#last()]
**** ...and emit a default value if empty: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#last-T-[Flux#last(T)]
** by skipping elements:
*** at the beginning of the sequence: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skip-long-[Flux#skip(long)]
**** ...based on a duration: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skip-java.time.Duration-[Flux#skip(Duration)]
*** at the end of the sequence: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipLast-int-[Flux#skipLast]
*** until a criteria is met (inclusive): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipUntil-java.util.function.Predicate-[Flux#skipUntil] (predicate-based), https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipUntilOther-org.reactivestreams.Publisher-[Flux#skipUntilOther] (companion publisher-based)
*** while a criteria is met (exclusive): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipWhile-java.util.function.Predicate-[Flux#skipWhile]
** by sampling items:
*** by duration: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sample-java.time.Duration-[Flux#sample(Duration)]
**** but keeping the first element in the sampling window instead of the last: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sampleFirst-java.time.Duration-[sampleFirst]
*** by a publisher-based window: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sample-org.reactivestreams.Publisher-[Flux#sample(Publisher)]
*** based on a publisher "timing out": https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sampleTimeout-java.util.function.Function-[Flux#sampleTimeout] (each element triggers a publisher, and is emitted if that publisher does not overlap with the next)

* I expect at most 1 element (error if more than one)...
** and I want an error if the sequence is empty: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#single--[Flux#single()]
** and I want a default value if the sequence is empty: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#single-T-[Flux#single(T)]
** and I accept an empty sequence as well: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#singleOrEmpty--[Flux#singleOrEmpty]



[[which.errors]]
== Handling Errors

* I want to create an erroring sequence: `error` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.lang.Throwable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.lang.Throwable-[Mono])...
** ...to replace the completion of a successful https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux]: `.concat(Flux.error(e))`
** ...to replace the *emission* of a successful https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono]: `.then(Mono.error(e))`
** ...if too much time elapses between onNexts: `timeout` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timeout-java.time.Duration-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timeout-java.time.Duration-[Mono])
** ...lazily: `error(Supplier<Throwable>)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.util.function.Supplier-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.util.function.Supplier-[Mono])

* I want the try/catch equivalent of:
** throwing: `error` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.lang.Throwable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.lang.Throwable-[Mono])
** catching an exception:
*** and falling back to a default value: `onErrorReturn` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorReturn-java.lang.Class-T-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorReturn-java.lang.Class-T-[Mono])
*** and falling back to another https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux] or https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono]: `onErrorResume` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorResume-java.lang.Class-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorResume-java.lang.Class-java.util.function.Function-[Mono])
*** and wrapping and re-throwing: `.onErrorMap(t -> new RuntimeException(t))` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorMap-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorMap-java.util.function.Function-[Mono])
** the finally block: `doFinally` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doFinally-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doFinally-java.util.function.Consumer-[Mono])
** the using pattern from Java 7: `using` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-[Mono]) factory method

* I want to recover from errors...
** by falling back:
*** to a value: `onErrorReturn` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorReturn-java.lang.Class-T-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorReturn-java.lang.Class-T-[Mono])
*** to a https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html?is-external=true[Publisher] or https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono], possibly different ones depending on the error: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorResume-java.lang.Class-java.util.function.Function-[Flux#onErrorResume] and https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorResume-java.lang.Class-java.util.function.Function-[Mono#onErrorResume]
** by retrying...
*** ...with a simple policy (max number of attempts): `retry()` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retry--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retry--[Mono]), `retry(long)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retry-long-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retry-long-[Mono])
*** ...triggered by a companion control Flux: `retryWhen` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retryWhen-reactor.util.retry.Retry-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retryWhen-reactor.util.retry.Retry-[Mono])
*** ...using a standard backoff strategy (exponential backoff with jitter): `retryWhen(Retry.backoff(...))` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retryWhen-reactor.util.retry.Retry-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retryWhen-reactor.util.retry.Retry-[Mono]) (see also other factory methods in https://projectreactor.io/docs/core/release/api/reactor/util/retry/Retry.html[Retry])

* I want to deal with backpressure "errors" (request max from upstream and apply the strategy when downstream does not produce enough request)...
** by throwing a special https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalStateException.html?is-external=true[IllegalStateException]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureError--[Flux#onBackpressureError]
** by dropping excess values: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureDrop--[Flux#onBackpressureDrop]
*** ...except the last one seen: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureLatest--[Flux#onBackpressureLatest]
** by buffering excess values (bounded or unbounded): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureBuffer--[Flux#onBackpressureBuffer]
*** ...and applying a strategy when bounded buffer also overflows: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureBuffer-int-reactor.core.publisher.BufferOverflowStrategy-[Flux#onBackpressureBuffer] with a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/BufferOverflowStrategy.html[BufferOverflowStrategy]

[[which.time]]
== Working with Time

* I want to associate emissions with a timing measured...
** ...with best available precision and versatility of provided data: `timed` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timed--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timed--[Mono])
*** https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Timed.html#elapsed--[Timed<T>#elapsed()] for https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true[Duration] since last `onNext`
*** https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Timed.html#timestamp--[Timed<T>#timestamp()] for https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html?is-external=true[Instant] representation of the epoch timestamp (milliseconds resolution)
*** https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Timed.html#elapsedSinceSubscription--[Timed<T>#elapsedSinceSubcription()] for https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true[Duration] since subscription (rather than last onNext)
*** can have nanoseconds resolution for elapsed https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true[Duration]s
** ...as a (legacy) https://projectreactor.io/docs/core/release/api/reactor/util/function/Tuple2.html[Tuple2<Long, T>]...
*** since last onNext: `elapsed` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#elapsed--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#elapsed--[Mono])
*** since the dawn of time (well, computer time): `timestamp` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timestamp--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timestamp--[Mono])


* I want my sequence to be interrupted if there is too much delay between emissions: `timeout` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timeout-java.time.Duration-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timeout-java.time.Duration-[Mono])

* I want to get ticks from a clock, regular time intervals: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#interval-java.time.Duration-[Flux#interval]

* I want to emit a single `0` after an initial delay: static https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delay-java.time.Duration-[Mono.delay].

* I want to introduce a delay:
** between each onNext signal: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delayElement-java.time.Duration-[Mono#delayElement], https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#delayElements-java.time.Duration-[Flux#delayElements]
** before the subscription happens: `delaySubscription` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#delaySubscription-java.time.Duration-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delaySubscription-java.time.Duration-[Mono])

[[which.window]]
== Splitting a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux]

* I want to split a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux<T>] into a `Flux<Flux<T>>`, by a boundary criteria:
** of size: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-int-[window(int)]
*** ...with overlapping or dropping windows: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-int-int-[window(int, int)]
** of time https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-java.time.Duration-[window(Duration)]
*** ...with overlapping or dropping windows: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-java.time.Duration-java.time.Duration-[window(Duration, Duration)]
** of size OR time (window closes when count is reached or timeout elapsed): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowTimeout-int-java.time.Duration-[windowTimeout(int, Duration)]
** based on a predicate on elements: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowUntil-java.util.function.Predicate-[windowUntil]
*** ...…emitting the element that triggered the boundary in the next window (`cutBefore` variant): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowUntil-java.util.function.Predicate-boolean-[.windowUntil(predicate, true)]
*** ...keeping the window open while elements match a predicate: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowWhile-java.util.function.Predicate-[windowWhile] (non-matching elements are not emitted)
** driven by an arbitrary boundary represented by onNexts in a control Publisher: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-org.reactivestreams.Publisher-[window(Publisher)], https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowWhen-org.reactivestreams.Publisher-java.util.function.Function-[windowWhen]

* I want to split a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux<T>] and buffer elements within boundaries together...
** into https://docs.oracle.com/javase/8/docs/api/java/util/List.html?is-external=true[List]:
*** by a size boundary: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-int-[buffer(int)]
**** ...with overlapping or dropping buffers: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-int-int-[buffer(int, int)]
*** by a duration boundary: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-java.time.Duration-java.time.Duration-[buffer(Duration)]
**** ...with overlapping or dropping buffers: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-java.time.Duration-java.time.Duration-[buffer(Duration, Duration)]
*** by a size OR duration boundary: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferTimeout-int-java.time.Duration-[bufferTimeout(int, Duration)]
*** by an arbitrary criteria boundary: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferUntil-java.util.function.Predicate-[bufferUntil(Predicate)]
**** ...putting the element that triggered the boundary in the next buffer: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferUntil-java.util.function.Predicate-boolean-[.bufferUntil(predicate, true)]
**** ...buffering while predicate matches and dropping the element that triggered the boundary: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferWhile-java.util.function.Predicate-[bufferWhile(Predicate)]
*** driven by an arbitrary boundary represented by onNexts in a control Publisher: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-org.reactivestreams.Publisher-[buffer(Publisher)], https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferWhen-org.reactivestreams.Publisher-java.util.function.Function-[bufferWhen]
** into an arbitrary "collection" type `C`: use variants like https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-int-java.util.function.Supplier-[buffer(int, Supplier<C>)]

* I want to split a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux<T>] so that element that share a characteristic end up in the same sub-flux: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#groupBy-java.util.function.Function-[groupBy(Function<T,K>)]
TIP: Note that this returns a `Flux<GroupedFlux<K, T>>`, each inner https://projectreactor.io/docs/core/release/api/reactor/core/publisher/GroupedFlux.html[GroupedFlux] shares the same `K` key accessible through https://projectreactor.io/docs/core/release/api/reactor/core/publisher/GroupedFlux.html#key--[key()].

[[which.blocking]]
== Going Back to the Synchronous World

Note: all of these methods except https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#toFuture--[Mono#toFuture] will throw an https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html?is-external=true[UnsupportedOperatorException] if called from
within a https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Scheduler.html[Scheduler] marked as "non-blocking only" (by default https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html#parallel--[parallel()] and https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html#single--[single()]).

* I have a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux<T>] and I want to:
** block until I can get the first element: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockFirst--[Flux#blockFirst]
*** ...with a timeout: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockFirst-java.time.Duration-[Flux#blockFirst(Duration)]
** block until I can get the last element (or null if empty): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockLast--[Flux#blockLast]
*** ...with a timeout: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockLast-java.time.Duration-[Flux#blockLast(Duration)]
** synchronously switch to an https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html?is-external=true[Iterable<T>]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#toIterable--[Flux#toIterable]
** synchronously switch to a Java 8 https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html[Stream<T>]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#toStream--[Flux#toStream]

* I have a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono<T>] and I want:
** to block until I can get the value: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#block--[Mono#block]
*** ...with a timeout: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#block-java.time.Duration-[Mono#block(Duration)]
** a https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html[CompletableFuture<T>]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#toFuture--[Mono#toFuture]

[[which.multicasting]]
== Multicasting a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux] to several https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Subscriber.html?is-external=true[Subscribers]

* I want to connect multiple https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Subscriber.html?is-external=true[Subscriber] to a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux]:
** and decide when to trigger the source with https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#connect--[connect()]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#publish--[publish()] (returns a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html[ConnectableFlux])
** and trigger the source immediately (late subscribers see later data): `share()` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#share--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#share--[Mono])
** and permanently connect the source when enough subscribers have registered: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#autoConnect-int-[.publish().autoConnect(n)]
** and automatically connect and cancel the source when subscribers go above/below the threshold: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#refCount-int-[.publish().refCount(n)]
*** ...but giving a chance for new subscribers to come in before cancelling: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#refCount-int-java.time.Duration-[.publish().refCount(n, Duration)]

* I want to cache data from a https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html?is-external=true[Publisher] and replay it to later subscribers:
** up to `n` elements: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cache-int-[cache(int)]
** caching latest elements seen within a https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true[Duration] (Time-To-Live): `cache(Duration)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cache-java.time.Duration-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#cache-java.time.Duration-[Mono])
*** ...but retain no more than `n` elements: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cache-int-java.time.Duration-[cache(int, Duration)]
** but without immediately triggering the source: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#replay--[Flux#replay] (returns a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html[ConnectableFlux])
